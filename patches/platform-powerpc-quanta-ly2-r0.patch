diff -rupN a/arch/powerpc/boot/dts/powerpc-quanta-ly2-r0.dts b/arch/powerpc/boot/dts/powerpc-quanta-ly2-r0.dts
--- a/arch/powerpc/boot/dts/powerpc-quanta-ly2-r0.dts	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/powerpc/boot/dts/powerpc-quanta-ly2-r0.dts	2015-05-18 13:39:01.764648504 -0700
@@ -0,0 +1,1464 @@
+/*
+ * <bsn.cl fy=2013 v=gpl>
+ * 
+ *        Copyright 2013, 2014 BigSwitch Networks, Inc.        
+ * 
+ * This program is free software; you can redistribute it
+ * and/or modify it under  the terms ofthe GNU General Public License as
+ * published by the Free Software Foundation;  either version 2 of the  License,
+ * or (at your option) any later version.
+ * 
+ * 
+ * </bsn.cl>
+ *
+ *
+ * Device tree for the Quanta LY2.
+ *
+ */
+
+
+/dts-v1/;
+
+/ {
+	model = "powerpc-quanta-ly2-r0";
+	compatible = "fsl,P2020RDB";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		ethernet0 = &enet0;
+		serial0 = &serial0;
+		serial1 = &serial1;
+		pci2 = &pci2;
+		mpic-msgr-block0 = &mpic_msgr_block0;
+		mpic-msgr-block1 = &mpic_msgr_block1;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		PowerPC,P2020@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			next-level-cache = <&l2>;
+		};
+
+		PowerPC,P2020@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			next-level-cache = <&l2>;
+		};
+	};
+
+	memory {
+		device_type = "memory";
+	};
+
+	localbus@ffe05000 {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		compatible = "fsl,p2020-elbc", "fsl,elbc", "simple-bus";
+		reg = <0 0xffe05000 0 0x1000>;
+		interrupts = <19 2>;
+		interrupt-parent = <&mpic>;
+
+		ranges = <0x0 0x0 0x0 0xee000000 0x2000000
+			  0x1 0x0 0x0 0xec000000 0x2000000>;
+
+		flash@0,0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "cfi-flash";
+			reg = <0x0 0x0 0x2000000>;
+			bank-width = <2>;
+
+			/*
+ 			 * ONIE flash layout (reverse-engineered:
+			 * - one ~27MiB loader partition
+			 * - 4 MiB onie partition
+			 * - uboot-env and uboot
+			 * - 32MiB leftover space for jffs2
+			 *
+			 */
+
+			flash@0 {
+				label = "onl-loader";
+				reg = <0x00000000 0x01b60000>;
+			};
+
+			flash@1 {
+				label = "onie";
+				reg = <0x01b60000 0x00400000>;
+				read-only;
+			};
+
+			flash@2 {
+				label = "uboot-env";
+				reg = <0x01f60000 0x00020000>;
+			};
+
+			flash@3 {
+				label = "uboot";
+				reg = <0x01f80000 0x00080000>;
+				read-only;
+			};
+
+		};
+
+		flash@1,0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "cfi-flash";
+			reg = <0x1 0x0 0x2000000>;
+			bank-width = <2>;
+
+			flash@4 {
+				label = "mnt-flash";
+				reg = <0x00000000 0x02000000>;
+			};
+		};
+	};
+
+	soc@ffe00000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		device_type = "soc";
+		compatible = "fsl,p2020-immr", "simple-bus";
+		ranges = <0x0  0x0 0xffe00000 0x100000>;
+		bus-frequency = <0>;
+
+		ecm-law@0 {
+			compatible = "fsl,ecm-law";
+			reg = <0x0 0x1000>;
+			fsl,num-laws = <12>;
+		};
+
+		ecm@1000 {
+			compatible = "fsl,p2020-ecm", "fsl,ecm";
+			reg = <0x1000 0x1000>;
+			interrupts = <17 2>;
+			interrupt-parent = <&mpic>;
+		};
+
+		memory-controller@2000 {
+			compatible = "fsl,p2020-memory-controller";
+			reg = <0x2000 0x1000>;
+			interrupt-parent = <&mpic>;
+			interrupts = <18 2>;
+		};
+
+		i2c@3000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			cell-index = <0>;
+			compatible = "fsl-i2c";
+			reg = <0x3000 0x100>;
+			interrupts = <43 2>;
+			interrupt-parent = <&mpic>;
+			dfsrr;
+
+			dimm@51 {
+				compatible = "at,spd";
+				reg = <0x51>;
+				read-only;
+			};
+
+			rtc@68 {
+				compatible = "dallas,ds1338";
+				reg = <0x68>;
+			};
+
+			mux@71 {
+				compatible = "nxp,pca9546";
+				reg = <0x71>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				i2c@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+
+					eeprom-mb@54 {
+						compatible = "at,24c02";
+						reg = <0x54>;
+						read-only;
+					};
+				};
+
+				i2c@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+				};
+
+				i2c@2 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <2>;
+
+					temp-fan@2e {
+						compatible = "quanta_ly_hwmon";
+						reg = <0x2e>;
+					};
+				};
+
+				i2c@3 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <3>;
+				};
+			};
+
+			mux@75 {
+				compatible = "nxp,pca9546";
+				reg = <0x75>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				i2c@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+
+					psu-1@58 {
+						compatible = "pmbus";
+						reg = <0x58>;
+					};
+				};
+
+				i2c@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+
+					psu-2@59 {
+						compatible = "pmbus";
+						reg = <0x59>;
+					};
+				};
+
+				i2c@2 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <2>;
+
+					gpio-psu-1@24 {
+						compatible = "nxp,pca9555";
+						reg = <0x24>;
+						#gpio-cells = <2>;
+						gpio-controller;
+					};
+				};
+
+				i2c@3 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <3>;
+
+					gpio-psu-2@25 {
+						compatible = "nxp,pca9555";
+						reg = <0x25>;
+						#gpio-cells = <2>;
+						gpio-controller;
+					};
+				};
+			};
+		};
+
+		i2c@3100 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			cell-index = <1>;
+			compatible = "fsl-i2c";
+			reg = <0x3100 0x100>;
+			interrupts = <43 2>;
+			interrupt-parent = <&mpic>;
+			dfsrr;
+
+			mux@25 {
+				compatible = "quanta_ly2_i2c_mux";
+				reg = <0x25>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				i2c@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+
+					eeprom-sfp-2@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-2@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+
+					eeprom-sfp-1@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-1@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@2 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <2>;
+
+					eeprom-sfp-4@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-4@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@3 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <3>;
+
+					eeprom-sfp-3@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-3@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@4 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <4>;
+
+					eeprom-sfp-6@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-6@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@5 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <5>;
+
+					eeprom-sfp-5@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-5@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@6 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <6>;
+
+					eeprom-sfp-8@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-8@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@7 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <7>;
+
+					eeprom-sfp-7@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-7@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@8 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <8>;
+
+					eeprom-sfp-10@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-10@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@9 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <9>;
+
+					eeprom-sfp-9@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-9@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@10 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <10>;
+
+					eeprom-sfp-12@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-12@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@11 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <11>;
+
+					eeprom-sfp-11@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-11@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@12 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <12>;
+
+					eeprom-sfp-14@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-14@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@13 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <13>;
+
+					eeprom-sfp-13@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-13@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@14 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <14>;
+
+					eeprom-sfp-16@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-16@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@15 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <15>;
+
+					eeprom-sfp-15@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-15@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+			};
+
+			mux@26 {
+				compatible = "quanta_ly2_i2c_mux";
+				reg = <0x26>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				i2c@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+
+					eeprom-sfp-18@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-18@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+
+					eeprom-sfp-17@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-17@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@2 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <2>;
+
+					eeprom-sfp-20@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-20@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@3 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <3>;
+
+					eeprom-sfp-19@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-19@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@4 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <4>;
+
+					eeprom-sfp-22@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-22@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@5 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <5>;
+
+					eeprom-sfp-21@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-21@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@6 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <6>;
+
+					eeprom-sfp-24@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-24@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@7 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <7>;
+
+					eeprom-sfp-23@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-23@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@8 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <8>;
+
+					eeprom-sfp-26@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-26@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@9 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <9>;
+
+					eeprom-sfp-25@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-25@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@10 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <10>;
+
+					eeprom-sfp-28@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-28@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@11 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <11>;
+
+					eeprom-sfp-27@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-27@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@12 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <12>;
+
+					eeprom-sfp-30@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-30@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@13 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <13>;
+
+					eeprom-sfp-29@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-29@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@14 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <14>;
+
+					eeprom-sfp-32@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-32@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@15 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <15>;
+
+					eeprom-sfp-31@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-31@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+			};
+
+			mux@27 {
+				compatible = "quanta_ly2_i2c_mux";
+				reg = <0x27>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				i2c@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+
+					eeprom-sfp-34@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-34@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+
+					eeprom-sfp-33@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-33@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@2 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <2>;
+
+					eeprom-sfp-36@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-36@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@3 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <3>;
+
+					eeprom-sfp-35@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-35@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@4 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <4>;
+
+					eeprom-sfp-38@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-38@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@5 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <5>;
+
+					eeprom-sfp-37@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-37@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@6 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <6>;
+
+					eeprom-sfp-40@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-40@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@7 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <7>;
+
+					eeprom-sfp-39@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-39@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@8 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <8>;
+
+					eeprom-sfp-42@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-42@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@9 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <9>;
+
+					eeprom-sfp-41@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-41@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@10 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <10>;
+
+					eeprom-sfp-44@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-44@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@11 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <11>;
+
+					eeprom-sfp-43@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-43@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@12 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <12>;
+
+					eeprom-sfp-46@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-46@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@13 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <13>;
+
+					eeprom-sfp-45@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-45@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@14 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <14>;
+
+					eeprom-sfp-48@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-48@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@15 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <15>;
+
+					eeprom-sfp-47@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-sfp-47@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+			};
+
+			mux@73 {
+				compatible = "nxp,pca9546";
+				reg = <0x73>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				i2c@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+
+					eeprom-qsfp-1@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-qsfp-1@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+
+					eeprom-qsfp-2@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-qsfp-2@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@2 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <2>;
+
+					eeprom-qsfp-3@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-qsfp-3@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+
+				i2c@3 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <3>;
+
+					eeprom-qsfp-4@50 {
+						compatible = "at,24c02";
+						reg = <0x50>;
+						read-only;
+					};
+					eeprom-qsfp-4@51 {
+						compatible = "at,24c02";
+						reg = <0x51>;
+						read-only;
+					};
+				};
+			};
+		};
+
+		serial0: serial@4500 {
+			cell-index = <0>;
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <0x4500 0x100>;
+			clock-frequency = <0>;
+			interrupts = <42 2>;
+			interrupt-parent = <&mpic>;
+		};
+
+		serial1: serial@4600 {
+			cell-index = <1>;
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <0x4600 0x100>;
+			clock-frequency = <0>;
+			interrupts = <42 2>;
+			interrupt-parent = <&mpic>;
+		};
+
+		dma@c300 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "fsl,eloplus-dma";
+			reg = <0xc300 0x4>;
+			ranges = <0x0 0xc100 0x200>;
+			cell-index = <1>;
+			dma-channel@0 {
+				compatible = "fsl,eloplus-dma-channel";
+				reg = <0x0 0x80>;
+				cell-index = <0>;
+				interrupt-parent = <&mpic>;
+				interrupts = <76 2>;
+			};
+			dma-channel@80 {
+				compatible = "fsl,eloplus-dma-channel";
+				reg = <0x80 0x80>;
+				cell-index = <1>;
+				interrupt-parent = <&mpic>;
+				interrupts = <77 2>;
+			};
+			dma-channel@100 {
+				compatible = "fsl,eloplus-dma-channel";
+				reg = <0x100 0x80>;
+				cell-index = <2>;
+				interrupt-parent = <&mpic>;
+				interrupts = <78 2>;
+			};
+			dma-channel@180 {
+				compatible = "fsl,eloplus-dma-channel";
+				reg = <0x180 0x80>;
+				cell-index = <3>;
+				interrupt-parent = <&mpic>;
+				interrupts = <79 2>;
+			};
+		};
+
+		gpio: gpio-controller@f000 {
+			#gpio-cells = <2>;
+			compatible = "fsl,mpc8572-gpio";
+			reg = <0xf000 0x100>;
+			interrupts = <47 0x2>;
+			interrupt-parent = <&mpic>;
+			gpio-controller;
+		};
+
+		l2: l2-cache-controller@20000 {
+			compatible = "fsl,p2020-l2-cache-controller";
+			reg = <0x20000 0x1000>;
+			cache-line-size = <32>;	// 32 bytes
+			cache-size = <0x80000>; // L2,512K
+			interrupt-parent = <&mpic>;
+			interrupts = <16 2>;
+		};
+
+		dma@21300 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "fsl,eloplus-dma";
+			reg = <0x21300 0x4>;
+			ranges = <0x0 0x21100 0x200>;
+			cell-index = <0>;
+			dma-channel@0 {
+				compatible = "fsl,eloplus-dma-channel";
+				reg = <0x0 0x80>;
+				cell-index = <0>;
+				interrupt-parent = <&mpic>;
+				interrupts = <20 2>;
+			};
+			dma-channel@80 {
+				compatible = "fsl,eloplus-dma-channel";
+				reg = <0x80 0x80>;
+				cell-index = <1>;
+				interrupt-parent = <&mpic>;
+				interrupts = <21 2>;
+			};
+			dma-channel@100 {
+				compatible = "fsl,eloplus-dma-channel";
+				reg = <0x100 0x80>;
+				cell-index = <2>;
+				interrupt-parent = <&mpic>;
+				interrupts = <22 2>;
+			};
+			dma-channel@180 {
+				compatible = "fsl,eloplus-dma-channel";
+				reg = <0x180 0x80>;
+				cell-index = <3>;
+				interrupt-parent = <&mpic>;
+				interrupts = <23 2>;
+			};
+		};
+
+/*		usb@22000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "fsl-usb2-dr";
+			reg = <0x22000 0x1000>;
+			interrupt-parent = <&mpic>;
+			interrupts = <28 0x2>;
+			phy_type = "ulpi";
+		};
+*/
+		ptp_timer: ptimer@24e00 {
+			compatible = "fsl,gianfar-ptp-timer";
+			reg = <0x24e00 0xb0>;
+		};
+
+		enet0: ethernet@24000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			cell-index = <0>;
+			device_type = "network";
+			model = "eTSEC";
+			compatible = "gianfar";
+			reg = <0x24000 0x1000>;
+			ranges = <0x0 0x24000 0x1000>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+			interrupts = <29 2 30 2 34 2>;
+			interrupt-parent = <&mpic>;
+			phy-connection-type = "sgmii";
+			phy-handle = <&phy0>;
+			tbi-handle = <&tbi0>;
+		};
+
+		mdio@24520 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "fsl,gianfar-mdio";
+			reg = <0x24520 0x20>;
+
+			phy0: ethernet-phy@0 {
+				reg = <0x1>;
+				device_type = "ethernet-phy";
+			};
+			tbi0: tbi-phy@11 {
+				reg = <0x11>;
+				device_type = "tbi-phy";
+			};
+		};
+
+		sdhci@2e000 {
+			compatible = "fsl,p2020-esdhc", "fsl,esdhc";
+			reg = <0x2e000 0x1000>;
+			interrupts = <72 0x2>;
+			interrupt-parent = <&mpic>;
+			clock-frequency = <0>;
+		};
+
+		crypto@30000 {
+			compatible = "fsl,sec3.1", "fsl,sec3.0", "fsl,sec2.4",
+				     "fsl,sec2.2", "fsl,sec2.1", "fsl,sec2.0";
+			reg = <0x30000 0x10000>;
+			interrupts = <45 2 58 2>;
+			interrupt-parent = <&mpic>;
+			fsl,num-channels = <4>;
+			fsl,channel-fifo-len = <24>;
+			fsl,exec-units-mask = <0xbfe>;
+			fsl,descriptor-types-mask = <0x3ab0ebf>;
+			fsl,multi-host-mode = "dual";
+			fsl,channel-remap = <0x3>;
+		};
+
+		mpic: pic@40000 {
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <2>;
+			reg = <0x40000 0x40000>;
+			compatible = "chrp,open-pic";
+			device_type = "open-pic";
+		};
+
+		mpic_msgr_block0: message@41400 {
+			compatible = "fsl,mpic-v3.1-msgr";
+			reg = <0x41400 0x200>;
+			interrupts = <
+				0xb0 2
+				0xb1 2
+				0xb2 2
+				0xb3 2>;
+			interrupt-parent = <&mpic>;
+		};
+
+		mpic_msgr_block1: message@42400 {
+			compatible = "fsl,mpic-v3.1-msgr";
+			reg = <0x42400 0x200>;
+			interrupts = <
+				0xb4 2
+				0xb5 2
+				0xb6 2
+				0xb7 2>;
+			interrupt-parent = <&mpic>;
+		};
+
+		msi@41600 {
+			compatible = "fsl,p2020-msi", "fsl,mpic-msi";
+			reg = <0x41600 0x80>;
+			msi-available-ranges = <0 0x100>;
+			interrupts = <
+				0xe0 0
+				0xe1 0
+				0xe2 0
+				0xe3 0
+				0xe4 0
+				0xe5 0
+				0xe6 0
+				0xe7 0>;
+			interrupt-parent = <&mpic>;
+		};
+
+		global-utilities@e0000 {
+			compatible = "fsl,p2020-guts";
+			reg = <0xe0000 0x1000>;
+			fsl,has-rstcr;
+		};
+	};
+
+	pci2: pcie@ffe0a000 {
+		compatible = "fsl,mpc8548-pcie";
+		device_type = "pci";
+		#interrupt-cells = <1>;
+		#size-cells = <2>;
+		#address-cells = <3>;
+		reg = <0 0xffe0a000 0 0x1000>;
+		bus-range = <0 255>;
+		ranges = <0x2000000 0x0 0xc0000000 0 0xc0000000 0x0 0x20000000
+			  0x1000000 0x0 0x00000000 0 0xffc20000 0x0 0x10000>;
+		clock-frequency = <100000000>;
+		interrupt-parent = <&mpic>;
+		interrupts = <26 2>;
+		interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
+		interrupt-map = <
+			/* IDSEL 0x0 */
+			0000 0x0 0x0 0x1 &mpic 0x0 0x1
+			0000 0x0 0x0 0x2 &mpic 0x1 0x1
+			0000 0x0 0x0 0x3 &mpic 0x2 0x1
+			0000 0x0 0x0 0x4 &mpic 0x3 0x1
+			>;
+		pcie@0 {
+			reg = <0x0 0x0 0x0 0x0 0x0>;
+			#size-cells = <2>;
+			#address-cells = <3>;
+			device_type = "pci";
+			ranges = <0x2000000 0x0 0xc0000000
+				  0x2000000 0x0 0xc0000000
+				  0x0 0x20000000
+
+				  0x1000000 0x0 0x0
+				  0x1000000 0x0 0x0
+				  0x0 0x10000>;
+		};
+	};
+};
diff -rupN a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
--- a/drivers/hwmon/Kconfig	2015-05-18 14:01:39.048702767 -0700
+++ b/drivers/hwmon/Kconfig	2015-05-18 13:51:58.972677584 -0700
@@ -1412,6 +1412,13 @@ config SENSORS_MC13783_ADC
         help
           Support for the A/D converter on MC13783 PMIC.
 
+config SENSORS_QUANTA_LY_HWMON
+ 	tristate "Quanta LYx hardware monitor"
+ 	depends on I2C
+ 	help
+ 	  If you say yes here you get support for the Quanta LYx hardware
+ 	  monitor.
+
 if ACPI
 
 comment "ACPI drivers"
diff -rupN a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
--- a/drivers/hwmon/Makefile	2015-05-18 14:01:39.048702767 -0700
+++ b/drivers/hwmon/Makefile	2015-05-18 13:48:34.908668001 -0700
@@ -130,6 +130,7 @@ obj-$(CONFIG_SENSORS_W83L785TS)	+= w83l7
 obj-$(CONFIG_SENSORS_W83L786NG)	+= w83l786ng.o
 obj-$(CONFIG_SENSORS_WM831X)	+= wm831x-hwmon.o
 obj-$(CONFIG_SENSORS_WM8350)	+= wm8350-hwmon.o
+obj-$(CONFIG_SENSORS_QUANTA_LY_HWMON)	+= quanta-ly-hwmon.o
 
 obj-$(CONFIG_PMBUS)		+= pmbus/
 
diff -rupN a/drivers/hwmon/quanta-ly-hwmon.c b/drivers/hwmon/quanta-ly-hwmon.c
--- a/drivers/hwmon/quanta-ly-hwmon.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/hwmon/quanta-ly-hwmon.c	2015-05-18 13:53:49.548681131 -0700
@@ -0,0 +1,297 @@
+/*
+ * <bsn.cl fy=2013 v=gpl>
+ *
+ *        Copyright 2013, 2014 BigSwitch Networks, Inc.
+ *
+ * This program is free software; you can redistribute it
+ * and/or modify it under  the terms ofthe GNU General Public License as
+ * published by the Free Software Foundation;  either version 2 of the  License,
+ * or (at your option) any later version.
+ *
+ *
+ * </bsn.cl>
+ *
+ * A hwmon driver for the Quanta LYx
+ */
+
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/log2.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+
+static const unsigned short normal_i2c[] = { 0x2C, 0x2E, 0x2F, I2C_CLIENT_END };
+
+#define QUANTA_LY_HWMON_REG_TEMP_INPUT_BASE 0x30
+#define QUANTA_LY_HWMON_REG_FAN_MODE 0x55
+#define QUANTA_LY_HWMON_REG_FAN_DIR 0x56
+#define QUANTA_LY_HWMON_REG_FAN_PWM_BASE 0x60
+#define QUANTA_LY_HWMON_REG_FAN_INPUT_BASE 0x80
+
+#define QUANTA_LY_HWMON_FAN_MANUAL_MODE 1
+#define QUANTA_LY_HWMON_FAN_AUTO_MODE 2
+
+#define QUANTA_LY_HWMON_NUM_FANS 8
+
+struct quanta_ly_hwmon_data {
+	struct device		*hwmon_dev;
+	struct attribute_group	attrs;
+	struct mutex		lock;
+};
+
+static int quanta_ly_hwmon_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id);
+static int quanta_ly_hwmon_remove(struct i2c_client *client);
+
+static const struct i2c_device_id quanta_ly_hwmon_id[] = {
+	{ "quanta_ly_hwmon", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, quanta_ly_hwmon_id);
+
+static struct i2c_driver quanta_ly_hwmon_driver = {
+	.class		= I2C_CLASS_HWMON,
+	.driver = {
+		.name	= "quanta_ly_hwmon",
+	},
+	.probe		= quanta_ly_hwmon_probe,
+	.remove		= quanta_ly_hwmon_remove,
+	.id_table	= quanta_ly_hwmon_id,
+	.address_list	= normal_i2c,
+};
+
+static ssize_t show_temp(struct device *dev, struct device_attribute *devattr,
+			 char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct quanta_ly_hwmon_data *data = i2c_get_clientdata(client);
+	int temp;
+
+	mutex_lock(&data->lock);
+	temp = i2c_smbus_read_byte_data(client,
+					QUANTA_LY_HWMON_REG_TEMP_INPUT_BASE
+					+ attr->index);
+	mutex_unlock(&data->lock);
+	return sprintf(buf, "%d\n", 1000 * temp);
+}
+
+static ssize_t show_fan(struct device *dev, struct device_attribute *devattr,
+			char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct quanta_ly_hwmon_data *data = i2c_get_clientdata(client);
+	int fan;
+
+	mutex_lock(&data->lock);
+	fan = i2c_smbus_read_word_swapped(client,
+					  QUANTA_LY_HWMON_REG_FAN_INPUT_BASE
+					  + 2 * attr->index);
+	mutex_unlock(&data->lock);
+	return sprintf(buf, "%d\n", fan);
+}
+
+static ssize_t show_pwm(struct device *dev, struct device_attribute *devattr,
+			char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct quanta_ly_hwmon_data *data = i2c_get_clientdata(client);
+	int pwm;
+
+	mutex_lock(&data->lock);
+	pwm = i2c_smbus_read_word_swapped(client,
+					  QUANTA_LY_HWMON_REG_FAN_PWM_BASE
+					  + 2 * attr->index);
+	mutex_unlock(&data->lock);
+        return sprintf(buf, "%d\n", pwm * 255 / 10000);
+}
+
+static ssize_t set_pwm(struct device *dev, struct device_attribute *devattr,
+		const char *buf, size_t count)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct quanta_ly_hwmon_data *data = i2c_get_clientdata(client);
+	long val;
+	int ret;
+
+	ret = kstrtol(buf, 10, &val);
+	if (ret)
+		return ret;
+	mutex_lock(&data->lock);
+	i2c_smbus_write_word_swapped(client,
+				     QUANTA_LY_HWMON_REG_FAN_PWM_BASE
+                                     + 2 * attr->index, val * 10000 / 255);
+	mutex_unlock(&data->lock);
+	return count;
+}
+
+static ssize_t show_fan_dir(struct device *dev,
+			    struct device_attribute *devattr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct quanta_ly_hwmon_data *data = i2c_get_clientdata(client);
+
+        int f2b = 0;
+        int b2f = 0;
+        int i;
+
+	mutex_lock(&data->lock);
+        for(i = 0; i < 4; i++) {
+            f2b += i2c_smbus_read_word_swapped(client,
+                                               QUANTA_LY_HWMON_REG_FAN_INPUT_BASE
+                                               + 2 * i);
+        }
+        for(i = 4; i < 8; i++) {
+            b2f += i2c_smbus_read_word_swapped(client,
+                                               QUANTA_LY_HWMON_REG_FAN_INPUT_BASE
+                                               + 2 * i);
+        }
+
+	mutex_unlock(&data->lock);
+        if(f2b) {
+            return sprintf(buf, "front-to-back");
+        }
+        if(b2f) {
+            return sprintf(buf, "back-to-front");
+        }
+        return sprintf(buf, "unknown");
+}
+
+static ssize_t set_fan_dir(struct device *dev,
+			   struct device_attribute *devattr, const char *buf,
+			   size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct quanta_ly_hwmon_data *data = i2c_get_clientdata(client);
+	int dir;
+
+	if (!strncmp(buf, "normal", 6))
+		dir = 0;
+	else if (!strncmp(buf, "reverse", 7))
+		dir = 1;
+	else
+		return -EINVAL;
+
+	mutex_lock(&data->lock);
+	i2c_smbus_write_byte_data(client,
+				  QUANTA_LY_HWMON_REG_FAN_DIR, dir);
+	mutex_unlock(&data->lock);
+	return count;
+}
+
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_temp, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp2_input, S_IRUGO, show_temp, NULL, 1);
+static SENSOR_DEVICE_ATTR(temp3_input, S_IRUGO, show_temp, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp4_input, S_IRUGO, show_temp, NULL, 3);
+static SENSOR_DEVICE_ATTR(temp5_input, S_IRUGO, show_temp, NULL, 4);
+static SENSOR_DEVICE_ATTR(fan1_input, S_IRUGO, show_fan, NULL, 0);
+static SENSOR_DEVICE_ATTR(fan2_input, S_IRUGO, show_fan, NULL, 1);
+static SENSOR_DEVICE_ATTR(fan3_input, S_IRUGO, show_fan, NULL, 2);
+static SENSOR_DEVICE_ATTR(fan4_input, S_IRUGO, show_fan, NULL, 3);
+static SENSOR_DEVICE_ATTR(fan5_input, S_IRUGO, show_fan, NULL, 4);
+static SENSOR_DEVICE_ATTR(fan6_input, S_IRUGO, show_fan, NULL, 5);
+static SENSOR_DEVICE_ATTR(fan7_input, S_IRUGO, show_fan, NULL, 6);
+static SENSOR_DEVICE_ATTR(fan8_input, S_IRUGO, show_fan, NULL, 7);
+static SENSOR_DEVICE_ATTR(pwm1, S_IWUSR | S_IRUGO, show_pwm, set_pwm, 0);
+static SENSOR_DEVICE_ATTR(pwm2, S_IWUSR | S_IRUGO, show_pwm, set_pwm, 1);
+static SENSOR_DEVICE_ATTR(pwm3, S_IWUSR | S_IRUGO, show_pwm, set_pwm, 2);
+static SENSOR_DEVICE_ATTR(pwm4, S_IWUSR | S_IRUGO, show_pwm, set_pwm, 3);
+static SENSOR_DEVICE_ATTR(pwm5, S_IWUSR | S_IRUGO, show_pwm, set_pwm, 4);
+static SENSOR_DEVICE_ATTR(pwm6, S_IWUSR | S_IRUGO, show_pwm, set_pwm, 5);
+static SENSOR_DEVICE_ATTR(pwm7, S_IWUSR | S_IRUGO, show_pwm, set_pwm, 6);
+static SENSOR_DEVICE_ATTR(pwm8, S_IWUSR | S_IRUGO, show_pwm, set_pwm, 7);
+static SENSOR_DEVICE_ATTR(fan_dir, S_IWUSR | S_IRUGO, show_fan_dir,
+			  set_fan_dir, 0);
+
+static struct attribute *quanta_ly_hwmon_attr[] = {
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_temp2_input.dev_attr.attr,
+	&sensor_dev_attr_temp3_input.dev_attr.attr,
+	&sensor_dev_attr_temp4_input.dev_attr.attr,
+	&sensor_dev_attr_temp5_input.dev_attr.attr,
+	&sensor_dev_attr_fan1_input.dev_attr.attr,
+	&sensor_dev_attr_fan2_input.dev_attr.attr,
+	&sensor_dev_attr_fan3_input.dev_attr.attr,
+	&sensor_dev_attr_fan4_input.dev_attr.attr,
+	&sensor_dev_attr_fan5_input.dev_attr.attr,
+	&sensor_dev_attr_fan6_input.dev_attr.attr,
+	&sensor_dev_attr_fan7_input.dev_attr.attr,
+	&sensor_dev_attr_fan8_input.dev_attr.attr,
+	&sensor_dev_attr_pwm1.dev_attr.attr,
+	&sensor_dev_attr_pwm2.dev_attr.attr,
+	&sensor_dev_attr_pwm3.dev_attr.attr,
+	&sensor_dev_attr_pwm4.dev_attr.attr,
+	&sensor_dev_attr_pwm5.dev_attr.attr,
+	&sensor_dev_attr_pwm6.dev_attr.attr,
+	&sensor_dev_attr_pwm7.dev_attr.attr,
+	&sensor_dev_attr_pwm8.dev_attr.attr,
+	&sensor_dev_attr_fan_dir.dev_attr.attr,
+	NULL
+};
+
+static int quanta_ly_hwmon_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct quanta_ly_hwmon_data *data;
+	int err;
+	int i;
+
+	data = devm_kzalloc(&client->dev, sizeof(struct quanta_ly_hwmon_data),
+			GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, data);
+	mutex_init(&data->lock);
+
+	dev_info(&client->dev, "%s chip found\n", client->name);
+
+	data->attrs.attrs = quanta_ly_hwmon_attr;
+	err = sysfs_create_group(&client->dev.kobj, &data->attrs);
+	if (err)
+		return err;
+
+	data->hwmon_dev = hwmon_device_register(&client->dev);
+	if (IS_ERR(data->hwmon_dev)) {
+		err = PTR_ERR(data->hwmon_dev);
+		goto exit_remove;
+	}
+
+	i2c_smbus_write_byte_data(client,
+				QUANTA_LY_HWMON_REG_FAN_MODE,
+				QUANTA_LY_HWMON_FAN_MANUAL_MODE);
+	for (i = 0; i < QUANTA_LY_HWMON_NUM_FANS; i++) {
+		u8 cmd = QUANTA_LY_HWMON_REG_FAN_PWM_BASE + i * 2;
+		i2c_smbus_write_word_swapped(client, cmd, 10000);
+	}
+
+	return 0;
+
+exit_remove:
+	sysfs_remove_group(&client->dev.kobj, &data->attrs);
+	return err;
+}
+
+static int quanta_ly_hwmon_remove(struct i2c_client *client)
+{
+	struct quanta_ly_hwmon_data *data = i2c_get_clientdata(client);
+
+	hwmon_device_unregister(data->hwmon_dev);
+	sysfs_remove_group(&client->dev.kobj, &data->attrs);
+	return 0;
+}
+
+module_i2c_driver(quanta_ly_hwmon_driver);
+
+MODULE_AUTHOR("Big Switch Networks <support@bigswitch.com>");
+MODULE_DESCRIPTION("Quanta LYx hardware monitor driver");
+MODULE_LICENSE("GPL");
diff -rupN a/drivers/i2c/muxes/i2c-mux-pca954x.c b/drivers/i2c/muxes/i2c-mux-pca954x.c
--- a/drivers/i2c/muxes/i2c-mux-pca954x.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/i2c/muxes/i2c-mux-pca954x.c	2015-05-18 13:55:04.600672335 -0700
@@ -0,0 +1,295 @@
+/*
+ * I2C multiplexer
+ *
+ * Copyright (c) 2008-2009 Rodolfo Giometti <giometti@linux.it>
+ * Copyright (c) 2008-2009 Eurotech S.p.A. <info@eurotech.it>
+ *
+ * This module supports the PCA954x series of I2C multiplexer/switch chips
+ * made by Philips Semiconductors.
+ * This includes the:
+ *	 PCA9540, PCA9542, PCA9543, PCA9544, PCA9545, PCA9546, PCA9547
+ *	 and PCA9548.
+ *
+ * These chips are all controlled via the I2C bus itself, and all have a
+ * single 8-bit register. The upstream "parent" bus fans out to two,
+ * four, or eight downstream busses or channels; which of these
+ * are selected is determined by the chip type and register contents. A
+ * mux can select only one sub-bus at a time; a switch can select any
+ * combination simultaneously.
+ *
+ * Based on:
+ *	pca954x.c from Kumar Gala <galak@kernel.crashing.org>
+ * Copyright (C) 2006
+ *
+ * Based on:
+ *	pca954x.c from Ken Harrenstien
+ * Copyright (C) 2004 Google, Inc. (Ken Harrenstien)
+ *
+ * Based on:
+ *	i2c-virtual_cb.c from Brian Kuschak <bkuschak@yahoo.com>
+ * and
+ *	pca9540.c from Jean Delvare <khali@linux-fr.org>.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+
+#include <linux/i2c/pca954x.h>
+
+#define PCA954X_MAX_NCHANS 8
+
+enum pca_type {
+	pca_9540,
+	pca_9542,
+	pca_9543,
+	pca_9544,
+	pca_9545,
+	pca_9546,
+	pca_9547,
+	pca_9548,
+};
+
+struct pca954x {
+	enum pca_type type;
+	struct i2c_adapter *virt_adaps[PCA954X_MAX_NCHANS];
+
+	u8 last_chan;		/* last register value */
+};
+
+struct chip_desc {
+	u8 nchans;
+	u8 enable;	/* used for muxes only */
+	enum muxtype {
+		pca954x_ismux = 0,
+		pca954x_isswi
+	} muxtype;
+};
+
+/* Provide specs for the PCA954x types we know about */
+static const struct chip_desc chips[] = {
+	[pca_9540] = {
+		.nchans = 2,
+		.enable = 0x4,
+		.muxtype = pca954x_ismux,
+	},
+	[pca_9543] = {
+		.nchans = 2,
+		.muxtype = pca954x_isswi,
+	},
+	[pca_9544] = {
+		.nchans = 4,
+		.enable = 0x4,
+		.muxtype = pca954x_ismux,
+	},
+	[pca_9545] = {
+		.nchans = 4,
+		.muxtype = pca954x_isswi,
+	},
+	[pca_9547] = {
+		.nchans = 8,
+		.enable = 0x8,
+		.muxtype = pca954x_ismux,
+	},
+	[pca_9548] = {
+		.nchans = 8,
+		.muxtype = pca954x_isswi,
+	},
+};
+
+static const struct i2c_device_id pca954x_id[] = {
+	{ "pca9540", pca_9540 },
+	{ "pca9542", pca_9540 },
+	{ "pca9543", pca_9543 },
+	{ "pca9544", pca_9544 },
+	{ "pca9545", pca_9545 },
+	{ "pca9546", pca_9545 },
+	{ "pca9547", pca_9547 },
+	{ "pca9548", pca_9548 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, pca954x_id);
+
+/* Write to mux register. Don't use i2c_transfer()/i2c_smbus_xfer()
+   for this as they will try to lock adapter a second time */
+static int pca954x_reg_write(struct i2c_adapter *adap,
+			     struct i2c_client *client, u8 val)
+{
+	int ret = -ENODEV;
+
+	if (adap->algo->master_xfer) {
+		struct i2c_msg msg;
+		char buf[1];
+
+		msg.addr = client->addr;
+		msg.flags = 0;
+		msg.len = 1;
+		buf[0] = val;
+		msg.buf = buf;
+		ret = adap->algo->master_xfer(adap, &msg, 1);
+	} else {
+		union i2c_smbus_data data;
+		ret = adap->algo->smbus_xfer(adap, client->addr,
+					     client->flags,
+					     I2C_SMBUS_WRITE,
+					     val, I2C_SMBUS_BYTE, &data);
+	}
+
+	return ret;
+}
+
+#define CONFIG_ALWAYS_SELECT_CHANNEL 1
+
+static int pca954x_select_chan(struct i2c_adapter *adap,
+			       void *client, u32 chan)
+{
+	struct pca954x *data = i2c_get_clientdata(client);
+	const struct chip_desc *chip = &chips[data->type];
+
+	u8 regval;
+	int ret = 0;
+
+	/* we make switches look like muxes, not sure how to be smarter */
+	if (chip->muxtype == pca954x_ismux)
+		regval = chan | chip->enable;
+	else
+		regval = 1 << chan;
+
+	/* Only select the channel if its different from the last channel */
+	if (CONFIG_ALWAYS_SELECT_CHANNEL || data->last_chan != regval) {
+            ret = pca954x_reg_write(adap, client, regval);
+            data->last_chan = regval;
+	}
+
+	return ret;
+}
+
+static int pca954x_deselect_mux(struct i2c_adapter *adap,
+				void *client, u32 chan)
+{
+	struct pca954x *data = i2c_get_clientdata(client);
+
+	/* Deselect active channel */
+	data->last_chan = 0;
+	return pca954x_reg_write(adap, client, data->last_chan);
+}
+
+/*
+ * I2C init/probing/exit functions
+ */
+static int pca954x_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adap = to_i2c_adapter(client->dev.parent);
+	struct pca954x_platform_data *pdata = client->dev.platform_data;
+	int num, force, class;
+	struct pca954x *data;
+	int ret = -ENODEV;
+
+	if (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_BYTE))
+		goto err;
+
+	data = kzalloc(sizeof(struct pca954x), GFP_KERNEL);
+	if (!data) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	i2c_set_clientdata(client, data);
+
+	/* Write the mux register at addr to verify
+	 * that the mux is in fact present. This also
+	 * initializes the mux to disconnected state.
+	 */
+	if (i2c_smbus_write_byte(client, 0) < 0) {
+		dev_warn(&client->dev, "probe failed\n");
+		goto exit_free;
+	}
+
+	data->type = id->driver_data;
+	data->last_chan = 0;		   /* force the first selection */
+
+	/* Now create an adapter for each channel */
+	for (num = 0; num < chips[data->type].nchans; num++) {
+		force = 0;			  /* dynamic adap number */
+		class = 0;			  /* no class by default */
+		if (pdata) {
+			if (num < pdata->num_modes) {
+				/* force static number */
+				force = pdata->modes[num].adap_id;
+				class = pdata->modes[num].class;
+			} else
+				/* discard unconfigured channels */
+				break;
+		}
+
+		data->virt_adaps[num] =
+			i2c_add_mux_adapter(adap, &client->dev, client,
+                                            force, num, class, pca954x_select_chan,
+                                            pca954x_deselect_mux);
+
+		if (data->virt_adaps[num] == NULL) {
+			ret = -ENODEV;
+			dev_err(&client->dev,
+				"failed to register multiplexed adapter"
+				" %d as bus %d\n", num, force);
+			goto virt_reg_failed;
+		}
+	}
+
+	dev_info(&client->dev,
+		 "registered %d multiplexed busses for I2C %s %s\n",
+		 num, chips[data->type].muxtype == pca954x_ismux
+				? "mux" : "switch", client->name);
+
+	return 0;
+
+virt_reg_failed:
+	for (num--; num >= 0; num--)
+		i2c_del_mux_adapter(data->virt_adaps[num]);
+exit_free:
+	kfree(data);
+err:
+	return ret;
+}
+
+static int pca954x_remove(struct i2c_client *client)
+{
+	struct pca954x *data = i2c_get_clientdata(client);
+	const struct chip_desc *chip = &chips[data->type];
+	int i, err;
+
+	for (i = 0; i < chip->nchans; ++i)
+		if (data->virt_adaps[i]) {
+			err = i2c_del_mux_adapter(data->virt_adaps[i]);
+			if (err)
+				return err;
+			data->virt_adaps[i] = NULL;
+		}
+
+	kfree(data);
+	return 0;
+}
+
+static struct i2c_driver pca954x_driver = {
+	.driver		= {
+		.name	= "pca954x",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= pca954x_probe,
+	.remove		= pca954x_remove,
+	.id_table	= pca954x_id,
+};
+
+module_i2c_driver(pca954x_driver);
+
+MODULE_AUTHOR("Rodolfo Giometti <giometti@linux.it>");
+MODULE_DESCRIPTION("PCA954x I2C mux/switch driver");
+MODULE_LICENSE("GPL v2");
diff -rupN a/drivers/i2c/muxes/Kconfig b/drivers/i2c/muxes/Kconfig
--- a/drivers/i2c/muxes/Kconfig	2015-05-18 14:01:39.076702769 -0700
+++ b/drivers/i2c/muxes/Kconfig	2015-05-18 13:56:18.272692152 -0700
@@ -49,4 +49,9 @@ config I2C_MUX_QUANTA
 	help
 	  If you say yes here you get support for the QUANTA I2C Mux devices
 
+config I2C_MUX_QUANTA_LY2
+        tristate "Quanta LY2 I2C multiplexer"
+        help
+          If you say yes here you get support for the Quanta LY2 I2C/GPIO
+          multiplexer.
 endmenu
diff -rupN a/drivers/i2c/muxes/Makefile b/drivers/i2c/muxes/Makefile
--- a/drivers/i2c/muxes/Makefile	2015-05-18 14:01:39.080702769 -0700
+++ b/drivers/i2c/muxes/Makefile	2015-05-18 13:57:01.776693234 -0700
@@ -6,5 +6,6 @@ obj-$(CONFIG_I2C_MUX_PCA9541)	+= pca9541
 obj-$(CONFIG_I2C_MUX_PCA954x)	+= pca954x.o
 obj-$(CONFIG_I2C_MUX_DNI_6448)	+= dni_6448_i2c_mux.o
 obj-$(CONFIG_I2C_MUX_QUANTA)	+= quanta-i2cmux.o
+obj-$(CONFIG_I2C_MUX_QUANTA_LY2)        += quanta-ly2-i2c-mux.o
 
 ccflags-$(CONFIG_I2C_DEBUG_BUS) := -DDEBUG
diff -rupN a/drivers/i2c/muxes/quanta-ly2-i2c-mux.c b/drivers/i2c/muxes/quanta-ly2-i2c-mux.c
--- a/drivers/i2c/muxes/quanta-ly2-i2c-mux.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/i2c/muxes/quanta-ly2-i2c-mux.c	2015-05-18 13:57:57.152691359 -0700
@@ -0,0 +1,357 @@
+/*
+ * <bsn.cl fy=2013 v=gpl>
+ * 
+ *        Copyright 2013, 2014 BigSwitch Networks, Inc.        
+ * 
+ * This program is free software; you can redistribute it
+ * and/or modify it under  the terms ofthe GNU General Public License as
+ * published by the Free Software Foundation;  either version 2 of the  License,
+ * or (at your option) any later version.
+ * 
+ * 
+ * </bsn.cl>
+ *
+ * An I2C multiplexer driver for the Quanta LY2
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/gpio.h>
+
+#define QUANTA_LY2_I2C_MUX_CHANNEL_FIRST 1
+
+#define QUANTA_LY2_I2C_MUX_NUM_CHANNELS 16
+
+/*
+ * 16 read GPIOs, 8 write GPIOs,
+ * treat them as a single GPIO chip,
+ * with the read GPIOs occurring first
+ */
+#define QUANTA_LY2_I2C_MUX_NUM_READ_GPIOS 16
+#define QUANTA_LY2_I2C_MUX_NUM_WRITE_GPIOS 8
+
+#define QUANTA_LY2_I2C_MUX_CMD_GET_GPIO 0
+#define QUANTA_LY2_I2C_MUX_CMD_SET_GPIO 1
+#define QUANTA_LY2_I2C_MUX_CMD_SET_CHANNEL 2
+
+struct quanta_ly2_i2c_mux {
+	struct i2c_client *client;
+	struct i2c_adapter *chan_adap[QUANTA_LY2_I2C_MUX_NUM_CHANNELS];
+	struct gpio_chip gpio_chip;
+	u8 last_chan;
+	u8 gpio_write_val;
+};
+
+static const struct i2c_device_id quanta_ly2_i2c_mux_id[] = {
+	{"quanta_ly_i2c_mux", 0},
+	{"quanta_ly2_i2c_mux", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, quanta_ly2_i2c_mux_id);
+
+/*
+ * pld.c does 3-byte transactions, but none of the GPIO
+ * definitions require more than 16 bits
+ */
+static int quanta_ly2_i2c_mux_reg_read(struct i2c_adapter *adap,
+				struct i2c_client *client,
+				u8 command, u16 *val)
+{
+	int ret = -ENODEV;
+
+	if (adap->algo->master_xfer) {
+		struct i2c_msg msg[2];
+		char buf[4];
+
+		msg[0].addr = client->addr;
+		msg[0].flags = 0;
+		msg[0].len = 1;
+		buf[0] = command;
+		msg[0].buf = &buf[0];
+
+                /* always receive 3 bytes, else the PLD freaks out */
+		msg[1].addr = client->addr;
+		msg[1].flags = I2C_M_RD;
+		msg[1].len = 3;
+		msg[1].buf = &buf[1];
+
+		ret = adap->algo->master_xfer(adap, msg, 2);
+                if (val != NULL && ret > -1)
+                        *val = ((buf[2] << 8) | buf[1]);
+	} else {
+		union i2c_smbus_data data;
+                data.block[0] = 3; /* block transfer length */
+		ret = adap->algo->smbus_xfer(adap, client->addr,
+					     client->flags,
+					     I2C_SMBUS_READ,
+					     command,
+					     I2C_SMBUS_I2C_BLOCK_DATA, &data);
+                if (val != NULL)
+                        *val = ((data.block[2] << 8) | data.block[1]);
+	}
+
+	return ret;
+}
+
+/*
+ * pld.c shows 3-byte output transactions;
+ * in our case we only need 8 bits to
+ * (1) select one of the 16 muxed i2c devices,
+ * (2) drive one of the 8 defined GPIO outputs
+ */
+static int quanta_ly2_i2c_mux_reg_write(struct i2c_adapter *adap,
+				struct i2c_client *client,
+				u8 command, u8 val)
+{
+	int ret = -ENODEV;
+
+	if (adap->algo->master_xfer) {
+		struct i2c_msg msg;
+		char buf[4];
+
+		msg.addr = client->addr;
+		msg.flags = 0;
+		msg.len = 3;
+		buf[0] = command;
+		buf[1] = val;
+                buf[2] = 0;
+                buf[3] = 0;
+		msg.buf = buf;
+		ret = adap->algo->master_xfer(adap, &msg, 1);
+	} else {
+		union i2c_smbus_data data;
+
+                data.block[0] = 3;
+                data.block[1] = val;
+                data.block[2] = 0;
+                data.block[3] = 0;
+
+		ret = adap->algo->smbus_xfer(adap, client->addr,
+					     client->flags,
+					     I2C_SMBUS_WRITE,
+					     command,
+					     I2C_SMBUS_I2C_BLOCK_DATA, &data);
+	}
+
+	return ret;
+}
+
+static void quanta_ly2_i2c_mux_gpio_set(struct gpio_chip *gc, unsigned offset,
+				int val)
+{
+	struct quanta_ly2_i2c_mux *data = container_of(
+		gc, struct quanta_ly2_i2c_mux, gpio_chip);
+
+        /* ignore write attempts to input GPIOs */
+        if (offset < QUANTA_LY2_I2C_MUX_NUM_READ_GPIOS) {
+                dev_warn(&data->client->dev,
+                         "ignoring GPIO write for input for pin %d\n",
+                         offset);
+                return;
+        }
+        offset -= QUANTA_LY2_I2C_MUX_NUM_READ_GPIOS;
+
+	if (val)
+		data->gpio_write_val |= (1 << offset);
+	else
+		data->gpio_write_val &= ~(1 << offset);
+
+	quanta_ly2_i2c_mux_reg_write(
+		data->client->adapter, data->client,
+		QUANTA_LY2_I2C_MUX_CMD_SET_GPIO,
+		data->gpio_write_val);
+}
+
+/*
+ * "read" one of the GPIOs.
+ * The first 16 (QUANTA_LY2_I2C_MUX_NUM_READ_GPIOS)
+ * are actual input GPIOs.
+ * the last 8 (QUANTA_LY2_I2C_MUX_NUM_WRITE_GPIOS)
+ * are output GPIOs, so readback just returns the cached value.
+ */
+static int quanta_ly2_i2c_mux_gpio_get(struct gpio_chip *gc, unsigned offset)
+{
+        int ret;
+        u16 buf;
+	struct quanta_ly2_i2c_mux *data = container_of(
+		gc, struct quanta_ly2_i2c_mux, gpio_chip);
+
+        if (offset >= QUANTA_LY2_I2C_MUX_NUM_READ_GPIOS) {
+                offset -= QUANTA_LY2_I2C_MUX_NUM_READ_GPIOS;
+                return (data->gpio_write_val & (1 << offset)) ? 1 : 0;
+        }
+
+        /* else, do a proper gpio read */
+        buf = 0;
+        ret = quanta_ly2_i2c_mux_reg_read(data->client->adapter,
+                                          data->client,
+                                          QUANTA_LY2_I2C_MUX_CMD_GET_GPIO,
+                                          &buf);
+        if (ret < 0) {
+                dev_err(&data->client->dev,
+                        "quanta_ly2_i2c_mux_reg_read failed\n");
+                return 0;
+        }
+        return (buf & (1 << offset)) ? 1 : 0;
+}
+
+static int quanta_ly2_i2c_mux_select_chan(struct i2c_adapter *adap,
+					void *client, u32 chan)
+{
+	struct quanta_ly2_i2c_mux *data = i2c_get_clientdata(client);
+	int ret = 0;
+	u32 c = QUANTA_LY2_I2C_MUX_CHANNEL_FIRST + chan;
+
+	if (data->last_chan != c) {
+		ret = quanta_ly2_i2c_mux_reg_write(
+			adap, client,
+			QUANTA_LY2_I2C_MUX_CMD_SET_CHANNEL, c);
+		data->last_chan = c;
+	}
+
+	return ret;
+}
+
+static int quanta_ly2_i2c_mux_release_chan(struct i2c_adapter *adap,
+					  void *client, u32 chan)
+{
+	struct quanta_ly2_i2c_mux *data = i2c_get_clientdata(client);
+	int ret = 0;
+
+	ret = quanta_ly2_i2c_mux_reg_write(
+		adap, client,
+		QUANTA_LY2_I2C_MUX_CMD_SET_CHANNEL, 0);
+	data->last_chan = 0;
+
+	return ret;
+}
+
+static struct gpio_chip quanta_ly2_i2c_mux_gpio_chip = {
+	.label = "quanta_ly2_i2c_mux_gpio_chip",
+	.owner = THIS_MODULE,
+	.ngpio = QUANTA_LY2_I2C_MUX_NUM_READ_GPIOS + QUANTA_LY2_I2C_MUX_NUM_WRITE_GPIOS,
+	.base = -1,
+	.set = quanta_ly2_i2c_mux_gpio_set,
+	.get = quanta_ly2_i2c_mux_gpio_get,
+};
+
+static int quanta_ly2_i2c_mux_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adap = client->adapter;
+	int chan;
+	struct quanta_ly2_i2c_mux *data;
+	int ret = -ENODEV;
+
+	if (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_BYTE_DATA))
+		goto err;
+
+	data = kzalloc(sizeof(struct quanta_ly2_i2c_mux), GFP_KERNEL);
+	if (!data) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	i2c_set_clientdata(client, data);
+	data->client = client;
+
+	if (i2c_smbus_write_byte(client, 0) < 0) {
+		dev_warn(&client->dev, "probe failed\n");
+		goto exit_free;
+	}
+
+	i2c_lock_adapter(adap);
+	quanta_ly2_i2c_mux_release_chan(adap, client, 0);
+	i2c_unlock_adapter(adap);
+
+	for (chan = 0; chan < QUANTA_LY2_I2C_MUX_NUM_CHANNELS; chan++) {
+		data->chan_adap[chan] =
+			i2c_add_mux_adapter(adap, &client->dev, client,
+					0, chan,
+					quanta_ly2_i2c_mux_select_chan,
+					quanta_ly2_i2c_mux_release_chan);
+
+		if (data->chan_adap[chan] == NULL) {
+			ret = -ENODEV;
+			dev_err(&client->dev,
+				"failed to register multiplexed adapter %d\n",
+				chan);
+			goto adap_reg_failed;
+		}
+	}
+
+	dev_info(&client->dev,
+		"registered %d multiplexed buses for I2C mux %s\n",
+		chan, client->name);
+
+	data->gpio_chip = quanta_ly2_i2c_mux_gpio_chip;
+	data->gpio_chip.dev = &client->dev;
+	data->gpio_write_val = 0xff;
+
+	ret = gpiochip_add(&data->gpio_chip);
+	if (ret) {
+		dev_err(&client->dev, "failed to register GPIOs\n");
+		goto adap_reg_failed;
+	}
+
+	dev_info(&client->dev,
+		"registered GPIOs for I2C mux %s (%d read, %d write)\n",
+		client->name,
+		QUANTA_LY2_I2C_MUX_NUM_READ_GPIOS,
+		QUANTA_LY2_I2C_MUX_NUM_WRITE_GPIOS);
+
+	return 0;
+
+adap_reg_failed:
+	for (chan--; chan >= 0; chan--)
+		i2c_del_mux_adapter(data->chan_adap[chan]);
+
+exit_free:
+	kfree(data);
+err:
+	return ret;
+}
+
+static int quanta_ly2_i2c_mux_remove(struct i2c_client *client)
+{
+	struct quanta_ly2_i2c_mux *data = i2c_get_clientdata(client);
+	int chan, ret;
+
+	for (chan = 0; chan < QUANTA_LY2_I2C_MUX_NUM_CHANNELS; chan++)
+		if (data->chan_adap[chan]) {
+			ret = i2c_del_mux_adapter(data->chan_adap[chan]);
+			if (ret)
+				return ret;
+			data->chan_adap[chan] = NULL;
+		}
+
+	ret = gpiochip_remove(&data->gpio_chip);
+	if (ret)
+		return ret;
+
+	kfree(data);
+	return 0;
+}
+
+static struct i2c_driver quanta_ly2_i2c_mux_driver = {
+	.driver = {
+		   .name = "quanta_ly2_i2c_mux",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = quanta_ly2_i2c_mux_probe,
+	.remove = quanta_ly2_i2c_mux_remove,
+	.id_table = quanta_ly2_i2c_mux_id,
+};
+
+module_i2c_driver(quanta_ly2_i2c_mux_driver);
+
+MODULE_AUTHOR("Big Switch Networks <support@bigswitch.com>");
+MODULE_DESCRIPTION("Quanta LY2 I2C multiplexer driver");
+MODULE_LICENSE("GPL");
diff -rupN a/drivers/net/tun.c b/drivers/net/tun.c
--- a/drivers/net/tun.c	2015-02-19 18:57:03.000000000 -0800
+++ b/drivers/net/tun.c	2015-05-20 09:41:10.210631541 -0700
@@ -74,7 +74,7 @@
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
-
+#include <linux/port.h>
 /* Uncomment to enable debugging */
 /* #define TUN_DEBUG 1 */
